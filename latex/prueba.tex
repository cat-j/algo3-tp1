\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=3cm, right=3cm, bottom=3cm, top=3.5cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}

\title{TP1 - Algoritmos y Estructuras de Datos III}
\date{2017-08-23}
\author{Catalina Gonzalo Juarros}

\begin{document}

\pagenumbering{gobble}

\maketitle

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Problema a resolver}

	\subsection{Descripci\'on}

		Dado un conjunto de \textit{i} agentes, queremos determinar la \textbf{mayor cantidad de agentes confiables} en base a una secuencia de \textit{a} preguntas respondidas por ellos. Cuando un agente responde una pregunta, dice si otro agente -que puede ser \'el mismo- es confiable. Para cierto subconjunto de agentes, decimos que todos son confiables si y s\'olo si:
	
		\begin{itemize}
		\item Ning\'un agente del conjunto dice que alg\'un agente del conjunto no es confiable: si Ricardo dice que Rub\'en no es confiable pero tanto Ricardo como Rub\'en est\'an en el conjunto, este no es una soluci\'on v\'alida.
		\item Ning\'un agente del conjunto dice que un agente que est\'a fuera del conjunto es confiable: si Ricardo est\'a en el conjunto y dice que Rub\'en es confiable, obligatoriamente debemos agregar a Rub\'en.
		\end{itemize}
		
		Cada agente se caracteriza por un n\'umero $1 \leq n \leq i$ y cada pregunta respondida se representa con un par $(x,y): 1 \leq x,y \leq i$, donde \textit{x} es el agente que respondi\'o la pregunta, \textit{y} es el agente sobre el que \textit{x} respondi\'o y el signo de \textit{y} indica si \textit{x} dijo que \textit{y} es o no confiable (positivo es s\'i, negativo es no). Por ejemplo, el par $(1,2)$ se lee como "1 dijo que 2 es confiable". Siempre hay al menos un agente, pero puede no haber preguntas respondidas. Puede deducirse que en ese caso todos los agentes son confiables.
		
		Llamaremos a un conjunto de agentes del mayor tama\~no posible una \textbf{soluci\'on \'optima}. En la secci\'on que sigue veremos ejemplos claros de soluciones \'optimas y casos en los que hay m\'as de una.
	
	\subsection{Ejemplos}
	
	\subsubsection{Caso 1}
	
		Analicemos las soluciones cuando tenemos 4 agentes y la secuencia de preguntas respondidas es $E = <(1,2), (1,-4), (2,-3), (3,1), (3,-4)>$:
		
		\begin{itemize}
		\item $<1, 2>$ es soluci\'on, ya que 1 dice que 2 es confiable. Observemos que $<1>$, entonces, no podr\'ia ser una soluci\'on. Observemos tambi\'en que no podemos extender nuestra soluci\'on, ya que 1 dice que 4 no es confiable y 2 dice que 3 no es confiable.
		\item $<2,4>$ tambi\'en es soluci\'on, porque a pesar de que 2 no dijo nada sobre 4, este subconjunto no rompe ninguna de las dos condiciones necesarias para ser una soluci\'on v\'alida. Tampoco podemos extenderla, por la misma raz\'on que la anterior.
		\item $<2>$ y $<4>$ son soluciones, pero obviamente no son \'optimas pues ya encontramos soluciones de 2 agentes.
		\end{itemize}
		
		Entonces, concluimos que la m\'axima cantidad de agentes confiables es 2. En este ejemplo se ve claramente que la soluci\'on \'optima \textbf{no necesariamente es \'unica}.
		
	\subsubsection{Caso 2}
	
		Veamos ahora qu\'e ocurre cuando tenemos un solo agente y la secuencia es $E = <(1,-1)>$:
		
		\begin{itemize}
		\item Observemos que una soluci\'on v\'alida \textbf{nunca} puede contener a 1, puesto que \'el mismo se considera no confiable.
		\item Pero 1 es el \'unico agente que tenemos, por lo que la \'unica soluci\'on v\'alida es el conjunto vac\'io.
		\end{itemize}
		
		En este caso hay una sola soluci\'on \'optima y la m\'axima cantidad de agentes es 0.


\section{Resoluci\'on}

	\begin{figure}[H]
		\includegraphics[width=100px]{peretti.jpg}
		\caption{Diego Peretti.}
		\label{peretti}
	\end{figure}
	
	\begin{figure}[H]
		\includegraphics[width=150px]{nariz.jpg}
		\caption{La nariz de Diego Peretti.}
		\label{nariz}
	\end{figure}
	
	\subsection{Idea}
	
	\subsection{Pseudoc\'odigo}

\section{Complejidad}

	\subsection{Caracterizaci\'on del peor caso}
	El algoritmo, como vimos en la secci\'on 2, consiste en probar subconjuntos de agentes hasta encontrar la m\'axima cantidad de informantes que pueden agregarse a la soluci\'on sin que uno contradiga a otro. Como es requisito que el arreglo que representa a cada subconjunto est\'e ordenado, s\'olo vamos a probar con \textbf{una} representaci\'on de cada subconjunto, por lo que la cantidad de soluciones posibles se corresponde con la cantidad de subconjuntos distintos de $\{1,...,i\}$ (es decir, el \textit{cardinal del conjunto de partes} de $\{1,...,i\}$). Este n\'umero es $2^{i}$. La justificaci\'on la voy a escribir cuando aprenda a hacer footnotes.
	\\
	En el peor caso, el algoritmo tiene que probar \textbf{todos} los subconjuntos, o sea $2^{i}$ soluciones candidatas. Lo voy a justificar cuando efectivamente haya hecho el algoritmo.

	\subsection{C\'alculo de complejidad}
	La complejidad de este algoritmo, en el peor caso, es

	\begin{equation*}	
	T(n) \in \mathcal{O}(2^{i} \times i^{2} \times \log{i} \times a )
	\end{equation*}
	
	\paragraph{Justificaci\'on}
	Dado que el algoritmo debe probar 

\section{C\'odigo fuente}

\section{Experimentaci\'on}

\end{document}